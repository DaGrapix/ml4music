new.corr <- cor(var.data)
var.data
var.data <- as.data.frame(data$PAR_ASE_M, data$PAR_ASE_MV, data$PAR_SFM_M, data$PAR_SFM_MV)
new.corr <- cor(var.data)
var.data <- as.data.frame(data$PAR_ASE_M, data$PAR_ASE_MV, data$PAR_SFM_M, data$PAR_SFM_MV)
var.data <- as.data.frame(c(data$PAR_ASE_M, data$PAR_ASE_MV, data$PAR_SFM_M, data$PAR_SFM_MV))
var.data <- as.data.frame(data$PAR_ASE_M, data$PAR_ASE_MV, data$PAR_SFM_M, data$PAR_SFM_MV)
data$PAR_ASE_M
var.data <- as.data.frame(PAR_ASE_M=data$PAR_ASE_M, PAR_ASE_MV=data$PAR_ASE_MV, PAR_SFM_M=data$PAR_SFM_M, PAR_SFM_MV=data$PAR_SFM_MV)
?as.dataframe
?as.data.frame
var.data <- as.data.frame(data, row.names = c("PAR_ASE_M", "PAR_ASE_MV", "PAR_SFM_M", "PAR_SFM_MV"))
data
data[[PAR_ASE_M]]
data[PAR_ASE_M]
data[[PAR_ASE_M,]]
data[[,PAR_ASE_M]]
data[,[PAR_ASE_M]]
data[[PAR_ASE_M]]
data1 <- data[ , ! names(data) %in% c("PAR_ASE_M", "PAR_ASE_MV", "PAR_SFM_M", "PAR_SFM_MV")]
data1 <- data[ , names(data) %in% c("PAR_ASE_M", "PAR_ASE_MV", "PAR_SFM_M", "PAR_SFM_MV")]
data1
names(data1)
var.data <- data[ , names(data) %in% c("PAR_ASE_M", "PAR_ASE_MV", "PAR_SFM_M", "PAR_SFM_MV")]
var.corr <- cor(var.data)
library(corrplot)
corplot(var.corr)
library(corrplot)
corplot(var.corr)
var.corr <- cor(var.data)
corplot(var.corr)
library(corrplot)
var.data <- data[ , names(data) %in% c("PAR_ASE_M", "PAR_ASE_MV", "PAR_SFM_M", "PAR_SFM_MV")]
var.corr <- cor(var.data)
corplot(var.corr)
library(corplot)
corrplot(var.corr)
high.corr.index.new[,1]]
high.corr.index.new[,1]
data <- data[,-high.corr.index.new[,1]]
data <- data[,-high.corr.index.new[,1]]
n <- nrow(data)
p <- ncol(data)
dim(data)
library(corrplot)
var.data <- data[ , names(data) %in% c("PAR_ASE_M", "PAR_ASE_MV", "PAR_SFM_M", "PAR_SFM_MV")]
var.corr <- cor(var.data)
corrplot(var.corr)
library(ggplot2)
library(plyr)
library(tidyverse)
rm(list=ls())
setwd(getwd())
data <- read.csv("Music_2023.txt",sep=";",header=TRUE)
dim(data)
n <- nrow(data)
p <- ncol(data)
summary(data)
## A FAIRE : Analyse uni-bi variée
##Question : Comment choisir les variables qu'on observe ?
# Proportion des genres musicaux
freq<-count(data,'GENRE')
freq
prop_classical<-freq[1,2]/n
prop_jazz<-freq[2,2]/n
prop_classical
prop_jazz
#ggplot(data, aes(x=reorder(GENRE, GENRE, function(x)-(length(x)/n)))) +
#geom_bar(fill='red') +  labs(x='Genre')
summary(data[,0:20])
summary(data$PAR_SC_V)
summary(data$PAR_SC)
summary(data$PAR_ASC_V)
rm(list=ls())
data <- read.csv("Music_2023.txt",sep=";",header=TRUE)
data.old <- data
n.old <- nrow(data)
p.old <- ncol(data)
data <- data.old[,-c(128:147)]
data$PAR_SC <- log(data$PAR_SC)
data$PAR_SC_V <- log(data$PAR_SC_V)
n <- nrow(data)
p <- ncol(data)
corr <- cor(x=data[,-p])
#selection des indices de la matrice de correlation > 0.99
high.corr.index.new <- which(corr > 0.99, arr.ind = TRUE) %>% unname
#selection des indices appartenant a la matrice triangulaire inferieure stricte,
#pour retirer les doublons, ainsi que les elements diagonaux.
lower.tri <- lower.tri(corr, diag=FALSE)
high.corr.index.new <- high.corr.index.new[which(lower.tri[high.corr.index.new]==TRUE),]
high.corr.index.new
correlated.variables <- matrix(c(names(data)[high.corr.index.new[,1]],
names(data)[high.corr.index.new[,2]]), nrow=nrow(high.corr.index.new))
correlated.variables
name.list <- as.vector(correlated.variables)
high.corr.index <- matrix(which(names(data) %in% name.list), nrow=nrow(high.corr.index.new))
high.corr.index
data <- data[,-high.corr.index.new[,1]]
n <- nrow(data)
p <- ncol(data)
dim(data)
library(corrplot)
var.data <- data[ , names(data) %in% c("PAR_ASE_M", "PAR_ASE_MV", "PAR_SFM_M", "PAR_SFM_MV")]
var.corr <- cor(var.data)
corrplot(var.corr)
>>>>>>> ebc347ea4a64f6bb6c9eb104f74c9b27cfc00c17
Mod0<-glm(y~PAR_TC+PAR_SC+PAR_SC_V+PAR_ASE_M,PAR_ASE_MV+PAR_SFM_M+PAR_SFM_MV,family=binomial,data=ndata)
library(ggplot2)
library(plyr)
library(stats)
library(tidyverse)
library(cowplot)
install.packages("cowplot")
library(ggplot2)
library(plyr)
library(stats)
library(tidyverse)
library(cowplot)
rm(list=ls())
setwd(getwd())
data <- read.csv("Music_2023.txt",sep=";",header=TRUE)
dim(data)
n <- nrow(data)
p <- ncol(data)
summary(data)
## A FAIRE : Analyse uni-bi variée
##Question : Comment choisir les variables qu'on observe ?
# Proportion des genres musicaux
freq<-plyr::count(data,'GENRE')
freq
prop_classical<-freq[1,2]/n
prop_jazz<-freq[2,2]/n
prop_classical
prop_jazz
density_plot = function(X,xlab,lxlab){
density<-ggplot(data,aes(x=X))+geom_density(col="blue")+xlab(xlab)
log_density<-ggplot(data,aes(x=log(X)))+geom_density(col="red")+xlab(lxlab)
plot_grid(density,log_density,labels=c("Densité","Densité log"),label_size=12,ncol=1,label_x = 0, label_y = 0,hjust = -0.5, vjust = -0.5)
}
density_plot(data$PAR_SC,xlab="PAR_SC",lxlab="log(PAR_SC)")
density_plot(data$PAR_SC_V,xlab="PAR_SC_V",lxlab="log(PAR_SC_V)")
density_plot(data$PAR_ASC_V,xlab="PAR_ASC_V",lxlab="log(PAR_ASC_V)")
rm(list=ls())
data <- read.csv("Music_2023.txt",sep=";",header=TRUE)
data.old<-data
data <- data.old[,-c(128:147)]
data$PAR_SC_V<-log(data$PAR_SC_V)
data$PAR_ASC_V<-log(data$PAR_ASC_V)
n <- nrow(data)
p <- ncol(data)
corr <- cor(x=data[,-p])
#selection des indices de la matrice de correlation > 0.99
high.corr.index.new <- which(corr > 0.99, arr.ind = TRUE) %>% unname
#selection des indices appartenant a la matrice triangulaire inferieure stricte,
#pour retirer les doublons, ainsi que les elements diagonaux.
lower.tri <- lower.tri(corr, diag=FALSE)
high.corr.index.new <- high.corr.index.new[which(lower.tri[high.corr.index.new]==TRUE),]
high.corr.index.new
correlated.variables <- matrix(c(names(data)[high.corr.index.new[,1]],
names(data)[high.corr.index.new[,2]]), nrow=nrow(high.corr.index.new))
correlated.variables
name.list <- as.vector(correlated.variables)
high.corr.index <- matrix(which(names(data) %in% name.list), nrow=nrow(high.corr.index.new))
high.corr.index
data <- data[,-high.corr.index.new[,1]]
n <- nrow(data)
p <- ncol(data)
dim(data)
y<-ifelse(data$GENRE=="Classical",1,0)
## On ajoute cette colonne au dataframe
ndata<-cbind(data,y)
## Représentation des valeurs d'une variable selon son genre musical, plot classique et boxplot.
myplot = function(x,Y,xlab=""){
plot(x,Y,xlab=xlab, col=Y+1,pch=Y+1);
boxplot(x~Y,xlab=xlab,horizontal=TRUE)
}
myplot(ndata$PAR_ASE_M,ndata$y,"PAR_ASE_M")
myplot(ndata$PAR_ASE_MV,ndata$y,"PAR_ASE_MV")
myplot(ndata$PAR_SFM_M,ndata$y,"PAR_SFM_M")
myplot(ndata$PAR_SFM_MV,ndata$y,"PAR_SFM_MV")
library(corrplot)
var.data <- data[ , names(data) %in% c("PAR_ASE_M", "PAR_ASE_MV", "PAR_SFM_M", "PAR_SFM_MV")]
var.corr <- cor(var.data)
corrplot(var.corr)
set.seed(103)
train=sample(c(TRUE,FALSE),n,rep=TRUE,prob=c(2/3,1/3))
Mod0<-glm(y~PAR_TC+PAR_SC+PAR_SC_V+PAR_ASE_M,PAR_ASE_MV+PAR_SFM_M+PAR_SFM_MV,family=binomial,data=ndata)
summary(Mod0)
?glm
## Définition de ModT
ModT<-glm(y~.,family=binomial,data=ndata[,-p])
library(ggplot2)
library(plyr)
library(stats)
library(tidyverse)
library(cowplot)
rm(list=ls())
setwd(getwd())
data <- read.csv("Music_2023.txt",sep=";",header=TRUE)
dim(data)
n <- nrow(data)
p <- ncol(data)
summary(data)
## A FAIRE : Analyse uni-bi variée
##Question : Comment choisir les variables qu'on observe ?
# Proportion des genres musicaux
freq<-plyr::count(data,'GENRE')
freq
prop_classical<-freq[1,2]/n
prop_jazz<-freq[2,2]/n
prop_classical
prop_jazz
density_plot = function(X,xlab,lxlab){
density<-ggplot(data,aes(x=X))+geom_density(col="blue")+xlab(xlab)
log_density<-ggplot(data,aes(x=log(X)))+geom_density(col="red")+xlab(lxlab)
plot_grid(density,log_density,labels=c("Densité","Densité log"),label_size=12,ncol=1,label_x = 0, label_y = 0,hjust = -0.5, vjust = -0.5)
}
density_plot(data$PAR_SC,xlab="PAR_SC",lxlab="log(PAR_SC)")
density_plot(data$PAR_SC_V,xlab="PAR_SC_V",lxlab="log(PAR_SC_V)")
density_plot(data$PAR_ASC_V,xlab="PAR_ASC_V",lxlab="log(PAR_ASC_V)")
rm(list=ls())
data <- read.csv("Music_2023.txt",sep=";",header=TRUE)
data.old<-data
data <- data.old[,-c(128:147)]
data$PAR_SC_V<-log(data$PAR_SC_V)
data$PAR_ASC_V<-log(data$PAR_ASC_V)
n <- nrow(data)
p <- ncol(data)
corr <- cor(x=data[,-p])
#selection des indices de la matrice de correlation > 0.99
high.corr.index.new <- which(corr > 0.99, arr.ind = TRUE) %>% unname
#selection des indices appartenant a la matrice triangulaire inferieure stricte,
#pour retirer les doublons, ainsi que les elements diagonaux.
lower.tri <- lower.tri(corr, diag=FALSE)
high.corr.index.new <- high.corr.index.new[which(lower.tri[high.corr.index.new]==TRUE),]
high.corr.index.new
correlated.variables <- matrix(c(names(data)[high.corr.index.new[,1]],
names(data)[high.corr.index.new[,2]]), nrow=nrow(high.corr.index.new))
correlated.variables
name.list <- as.vector(correlated.variables)
high.corr.index <- matrix(which(names(data) %in% name.list), nrow=nrow(high.corr.index.new))
high.corr.index
data <- data[,-high.corr.index.new[,1]]
n <- nrow(data)
p <- ncol(data)
dim(data)
y<-ifelse(data$GENRE=="Classical",1,0)
## On ajoute cette colonne au dataframe
ndata<-cbind(data,y)
## Représentation des valeurs d'une variable selon son genre musical, plot classique et boxplot.
myplot = function(x,Y,xlab=""){
plot(x,Y,xlab=xlab, col=Y+1,pch=Y+1);
boxplot(x~Y,xlab=xlab,horizontal=TRUE)
}
myplot(ndata$PAR_ASE_M,ndata$y,"PAR_ASE_M")
myplot(ndata$PAR_ASE_MV,ndata$y,"PAR_ASE_MV")
myplot(ndata$PAR_SFM_M,ndata$y,"PAR_SFM_M")
myplot(ndata$PAR_SFM_MV,ndata$y,"PAR_SFM_MV")
library(corrplot)
var.data <- data[ , names(data) %in% c("PAR_ASE_M", "PAR_ASE_MV", "PAR_SFM_M", "PAR_SFM_MV")]
var.corr <- cor(var.data)
corrplot(var.corr)
set.seed(103)
train=sample(c(TRUE,FALSE),n,rep=TRUE,prob=c(2/3,1/3))
## Définition de ModT
ModT<-glm(y~.,family=binomial,data=ndata[,-p])
summary(ModT)
p_value<-coef(summary(ModT))[-1,4]
index_var_Mod1<-which(p_value>0.05)
var_Mod1<-names(data[index_var_Mod1])
data[index_var_Mod1]
index_var_Mod1
formula_Mod1<-as.formula(paste("y ~",paste(var_Mod1, collapse= "+")))
Mod1<-glm(formula = formula_Mod1,family=binomial,data=ndata[-p])
index_var_Mod2<-which(p_value>0.2)
var_Mod2<-names(data[index_var_Mod2])
formula_Mod2<-as.formula(paste("y ~",paste(var_Mod2, collapse= "+")))
Mod2<-glm(formula = formula_Mod2,family=binomial,data=ndata[-p])
Mod0<-glm(y~PAR_TC+PAR_SC+PAR_SC_V+PAR_ASE_M,PAR_ASE_MV+PAR_SFM_M+PAR_SFM_MV,family=binomial,data=ndata)
summary(Mod0)
## Pour ModT, il faut enlever les variables fortement corrélées et peut être aussi les autres qui sont évoquées.
## Étape 1 : modifier ndata en fonction des variables que l'on enlève
## Étape 2 : Définir le modèle :
## Définition de ModT
ModT<-glm(y~.,family=binomial,data=ndata[,-p])
summary(ModT)
## On récupère les p-value des variables
p_value<-coef(summary(ModT))[-1,4]
## On sélectionne celle qui ont un niveau de significativité de 5% et on crée la formule de notre modèle Mod1
index_var_Mod1<-which(p_value>0.05)
var_Mod1<-names(data[index_var_Mod1])
formula_Mod1<-as.formula(paste("y ~",paste(var_Mod1, collapse= "+")))
Mod1<-glm(formula = formula_Mod1,family=binomial,data=ndata[-p])
index_var_Mod2<-which(p_value>0.2)
var_Mod2<-names(data[index_var_Mod2])
formula_Mod2<-as.formula(paste("y ~",paste(var_Mod2, collapse= "+")))
Mod2<-glm(formula = formula_Mod2,family=binomial,data=ndata[-p])
step <- stepAIC(ModT)
## ModAIC
library(MASS)
step <- stepAIC(ModT)
step$anova
save.image("C:/Users/pc/Desktop/sta203_projet/step.RData")
load(step.RData)
load("step.RData")
library(ROCR)
install.packages("ROCR")
setwd("F:/ZZ/STA203/TP9")
library(ggplot2)
rm(list=objects());graphics.off()
spam = read.table("spam.data")
dim(spam) # 4601 x 58
p = ncol(spam)-1          # nombre de variables explicatives
n = nrow(spam)
names(spam)[p+1] = "Y"
spam$Y
res = glm(Y~.,data=spam,family=binomial)         # estimation
setwd("F:/ZZ/sta203_projet")
rm(list=ls())
data <- read.csv("Music_2023.txt",sep=";",header=TRUE)
n <- nrow(data)
p <- ncol(data)
y<-ifelse(data$GENRE=="Classical",1,0)
## On ajoute cette colonne au dataframe
ndata<-cbind(data,y)
## Représentation des valeurs d'une variable selon son genre musical, plot classique et boxplot.
myplot = function(x,Y,xlab=""){
plot(x,Y,xlab=xlab, col=Y+1,pch=Y+1);
boxplot(x~Y,xlab=xlab,horizontal=TRUE)
}
myplot(ndata$PAR_ASE_M,ndata$y,"PAR_ASE_M")
myplot(ndata$PAR_ASE_MV,ndata$y,"PAR_ASE_MV")
myplot(ndata$PAR_SFM_M,ndata$y,"PAR_SFM_M")
myplot(ndata$PAR_SFM_MV,ndata$y,"PAR_SFM_MV")
library(corrplot)
var.data <- data[ , names(data) %in% c("PAR_ASE_M", "PAR_ASE_MV", "PAR_SFM_M", "PAR_SFM_MV")]
var.corr <- cor(var.data)
corrplot(var.corr)
set.seed(103)
train=sample(c(TRUE,FALSE),n,rep=TRUE,prob=c(2/3,1/3))
x <- data[,-p]
train=sample(c(TRUE,FALSE), n-1, rep=TRUE, prob=c(2/3,1/3))
x.train <- x[which(train),]
x.test <- x[which(train==FALSE),]
ndata<-cbind(x.train,y)
rm(list=ls())
data <- read.csv("Music_2023.txt",sep=";",header=TRUE)
data.old<-data
data <- data.old[,-c(128:147)]
data$PAR_SC_V<-log(data$PAR_SC_V)
data$PAR_ASC_V<-log(data$PAR_ASC_V)
n <- nrow(data)
p <- ncol(data)
set.seed(103)
train=sample(c(TRUE,FALSE),n,rep=TRUE,prob=c(2/3,1/3))
x <- data[,-p]
train=sample(c(TRUE,FALSE), n-1, rep=TRUE, prob=c(2/3,1/3))
x.train <- x[which(train),]
x.test <- x[which(train==FALSE),]
ndata<-cbind(x.train,y)
set.seed(103)
train=sample(c(TRUE,FALSE),n,rep=TRUE,prob=c(2/3,1/3))
x <- data[, -p]
y <- data[, p]
train=sample(c(TRUE,FALSE), n-1, rep=TRUE, prob=c(2/3,1/3))
x.train <- x[which(train),]
x.test <- x[which(train==FALSE),]
ndata<-cbind(x.train,y)
y
set.seed(103)
train=sample(c(TRUE,FALSE),n,rep=TRUE,prob=c(2/3,1/3))
x <- data[, -p]
y <- ifelse(data$GENRE=="Classical", 1, 0)
train=sample(c(TRUE,FALSE), n-1, rep=TRUE, prob=c(2/3,1/3))
x.train <- x[which(train),]
x.test <- x[which(train==FALSE),]
ndata<-cbind(x.train,y)
y
set.seed(103)
train=sample(c(TRUE,FALSE),n,rep=TRUE,prob=c(2/3,1/3))
x <- data[, -p]
y <- ifelse(data$GENRE=="Classical", 1, 0)
train=sample(c(TRUE,FALSE), n-1, rep=TRUE, prob=c(2/3,1/3))
x.train <- x[which(train),]
x.test <- x[which(train==FALSE),]
y.train <- y[which(train)]
y.test <- x[which(train==FALSE)]
y.test <- x[which(train==FALSE)]
set.seed(103)
train=sample(c(TRUE,FALSE),n,rep=TRUE,prob=c(2/3,1/3))
x <- data[, -p]
y <- ifelse(data$GENRE=="Classical", 1, 0)
train=sample(c(TRUE,FALSE), n-1, rep=TRUE, prob=c(2/3,1/3))
x.train <- x[which(train),]
x.test <- x[which(train==FALSE),]
y.train <- y[which(train)]
y.test <- y[which(train==FALSE)]
df.train <- cbind(x.train,y.train)
set.seed(103)
train=sample(c(TRUE,FALSE),n,rep=TRUE,prob=c(2/3,1/3))
x <- data[, -p]
y <- ifelse(data$GENRE=="Classical", 1, 0)
train=sample(c(TRUE,FALSE), n-1, rep=TRUE, prob=c(2/3,1/3))
x.train <- x[which(train),]
x.test <- x[which(train==FALSE),]
y.train <- y[which(train)]
y.test <- y[which(train==FALSE)]
df.train <- cbind(x.train,y.train)
df.test <- cbind(x.test,y.test)
x.train
Mod0<-glm(y~PAR_TC+PAR_SC+PAR_SC_V+PAR_ASE_M,PAR_ASE_MV+PAR_SFM_M+PAR_SFM_MV,family=binomial, data=df.train)
set.seed(103)
train=sample(c(TRUE,FALSE),n,rep=TRUE,prob=c(2/3,1/3))
x <- data[, -p]
y <- ifelse(data$GENRE=="Classical", 1, 0)
train=sample(c(TRUE,FALSE), n-1, rep=TRUE, prob=c(2/3,1/3))
x.train <- x[which(train),]
x.test <- x[which(train==FALSE),]
y.train <- y[which(train)]
y.test <- y[which(train==FALSE)]
df.train <- cbind(x.train,y.train)
df.test <- cbind(x.test,y.test)
x.train
x.train
set.seed(103)
train=sample(c(TRUE,FALSE),n,rep=TRUE,prob=c(2/3,1/3))
x <- data[, -p]
y <- ifelse(data$GENRE=="Classical", 1, 0)
train=sample(c(TRUE,FALSE), n-1, rep=TRUE, prob=c(2/3,1/3))
x.train <- x[which(train),]
x.test <- x[which(train==FALSE),]
y.train <- y[which(train)]
y.test <- y[which(train==FALSE)]
df.train <- cbind(x.train,y.train)
df.test <- cbind(x.test,y.test)
Mod0 <- glm(y~PAR_TC+PAR_SC+PAR_SC_V+PAR_ASE_M,PAR_ASE_MV+PAR_SFM_M+PAR_SFM_MV,family=binomial, data=df.train)
x.train$PAR_TC
dim(x.train)
df.train <- cbind(x.train,y=y.train)
Mod0 <- glm(y~PAR_TC+PAR_SC+PAR_SC_V+PAR_ASE_M,PAR_ASE_MV+PAR_SFM_M+PAR_SFM_MV,family=binomial, data=df.train)
df.test <- cbind(x.test,y=y.test)
set.seed(103)
train=sample(c(TRUE,FALSE),n,rep=TRUE,prob=c(2/3,1/3))
x <- data[, -p]
y <- ifelse(data$GENRE=="Classical", 1, 0)
train=sample(c(TRUE,FALSE), n-1, rep=TRUE, prob=c(2/3,1/3))
x.train <- x[which(train),]
x.test <- x[which(train==FALSE),]
y.train <- y[which(train)]
y.test <- y[which(train==FALSE)]
df.train <- cbind(x.train,y=y.train)
df.test <- cbind(x.test,y=y.test)
Mod0 <- glm(y~PAR_TC+PAR_SC+PAR_SC_V+PAR_ASE_M,PAR_ASE_MV+PAR_SFM_M+PAR_SFM_MV,family=binomial, data=df.train)
summary(Mod0)
## Définition de ModT
ModT<-glm(y~.,family=binomial,data=df.train)
p_value<-coef(summary(ModT))[-1,4]
index_var_Mod1 <- which(p_value>0.05)
var_Mod1 <- names(data[index_var_Mod1])
formula_Mod1 <- as.formula(paste("y ~",paste(var_Mod1, collapse= "+")))
set.seed(103)
train=sample(c(TRUE,FALSE),n,rep=TRUE,prob=c(2/3,1/3))
x <- data[, -p]
y <- ifelse(data$GENRE=="Classical", 1, 0)
train=sample(c(TRUE,FALSE), n-1, rep=TRUE, prob=c(2/3,1/3))
x.train <- x[which(train),]
x.test <- x[which(train==FALSE),]
y.train <- y[which(train)]
y.test <- y[which(train==FALSE)]
df.train <- cbind(x.train,y=y.train)
df.test <- cbind(x.test,y=y.test)
n.train <- nrow(df.train)
p.train <- ncol(df.train)
n.test <- nrow(df.test)
p.test <- ncol(df.test)
Mod0 <- glm(y~PAR_TC+PAR_SC+PAR_SC_V+PAR_ASE_M,PAR_ASE_MV+PAR_SFM_M+PAR_SFM_MV,family=binomial, data=df.train)
summary(Mod0)
## Définition de ModT
ModT <- glm(y~.,family=binomial,data=df.train)
## Définition de ModT
ModT <- glm(y~.,family=binomial,data=df.train)
summary(ModT)
p_value <- coef(summary(ModT))[-1,4]
p_value
Mod1<-glm(formula = formula_Mod1, family=binomial, data=df.train)
## Définition de Mod0
Mod0 <- glm(y~PAR_TC+PAR_SC+PAR_SC_V+PAR_ASE_M,PAR_ASE_MV+PAR_SFM_M+PAR_SFM_MV,family=binomial, data=df.train)
summary(Mod0)
## Pour ModT, il faut enlever les variables fortement corrélées et peut être aussi les autres qui sont évoquées.
## Étape 1 : modifier ndata en fonction des variables que l'on enlève
## Étape 2 : Définir le modèle :
## Définition de ModT
ModT <- glm(y~.,family=binomial,data=df.train)
summary(ModT)
## On récupère les p-value des variables
p_value <- coef(summary(ModT))[-1,4]
## On sélectionne celle qui ont un niveau de significativité de 5% et on crée la formule de notre modèle Mod1
index_var_Mod1 <- which(p_value>0.05)
var_Mod1 <- names(data[index_var_Mod1])
formula_Mod1 <- as.formula(paste("y ~",paste(var_Mod1, collapse= "+")))
Mod1<-glm(formula <- formula_Mod1, family=binomial, data=df.train)
index_var_Mod2 <- which(p_value>0.2)
var_Mod2 <- names(data[index_var_Mod2])
formula_Mod2 <- as.formula(paste("y ~",paste(var_Mod2, collapse= "+")))
Mod2<-glm(formula=formula_Mod2, family=binomial, data=df.train)
## ModAIC
library(MASS)
#step <- stepAIC(ModT)
test_data <- read.csv("Music_test.txt",header=TRUE,sep=";")
dim(test_data)
dim(data[-train,])
dim(data[train,])
